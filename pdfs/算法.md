# 算法

本书使用的语言好像是java

## 第一章 基础

本章介绍的就是学习算法和数据结构所需要的基本工具。

> 算法：一种有序、确定、有效的并适合用计算机程序来实现的解决问题的方法。
> 算法是计算机科学的基础，是这个领域研究的核心。
> 数据结构是算法的副产品或是结果。
> 学习算法的主要原因是它们能节约非常多的资源。

### 1.1 基础编程模型

#### 1.1.1 java 程序的基本结构

```java
public class HelloWorld { 
    public static void main(String[] args) { 
        System.out.println("Hello World!");
        func();
    }
    public static void func() {
        System.out.println("Hello World!");
     }
}
```

#### 1.1.2 原始数据类型与表达式

- int - 整形
- double - 浮点型
- boolean - 布尔型
- char - 字符型

#### 1.1.3 语句

逻辑的基本语句有：声明、赋值、条件、循环、选择、调用和返回。

#### 1.1.4 简便记法

#### 1.1.5 数组

数组是存储多个相同类型的数据。

#### 1.1.6 静态方法

#### 1.1.7 API

API：应用程序接口

#### 1.1.8 字符串

在java中，字符串是被封装好的类String。

由自己的方法和属性。

#### 1.1.9 输入输出

#### 1.1.10 二分查找

我们要学习的第一个java程序的示例程序就是**著名**、**高效**并且**应用广泛**的**二分查找算法**。

```cpp
class BinarySearch {
/*
* 0. 前提，数组必须是有序的（假设它是正序）
* 1. 先得出数组的整体大小
* 2. 从中间开始比较，若要找的数字比中间值大，则将头指针移到中间值
* 3. 返回第一步
*/
public:
	int search(int arr[], int i, int size) {
		int max = size - 1;
		int min = 0;
		int mid = (max + min) / 2;
		while (max >= min) {
			if (arr[mid] == i) {
				return mid;
			}
			else if (arr[mid] < i) {
				min = mid + 1;
				mid = (max + min) / 2;
			}
			else if (arr[mid] > i) {
				max = mid - 1;
				mid = (max + min) / 2;
			}
		}
		return -1; // 没找到
	}
};

```

#### 1.1.11 展望

前进的这一步被称为数据抽象，有时也被称为面向对象编程，它是我们下一章的主题。

#### 1.1 练习

### 1.2 数据抽象

数据类型指的是一组值和一组对这些指的操作的集合。

抽象数据类型（ADT）是一种能够对使用者隐藏数据表示的数据类型。

抽象数据类型（实际上是class类）的主要不同之处在于它将数据和函数的实现关联，并将数据的表示方式隐藏起来。

详见java类

### 1.3 背包、队列和栈

许多基础数据类型都和对象的集合有关。

具体来说，数据类型的值就是一组对象的集合，所有操作都是关于添加、删除或是访问集合中的对象。

#### 1.3.1 API

背包：`public class  Bag<Item> implements Iterable<Item>`

|方法|功能|
|-|-|
|Bag()|构造一个空的背包|
|void add(Item item)|添加一个元素|
|boolean isEmpty()|判断背包是否为空|
|int size()|返回背包中元素的个数|

先进先出队列：`public class Queue<Item> implements Iterable<Item>`

|方法|功能|
|-|-|
|Queue()|构造一个空的队列|
|void enqueue(Item item)|添加一个元素|
|Item dequeue()|删除一个元素|
|boolean isEmpty()|队列是否为空|
|int size()|返回队列中元素的个数|

栈：`public class Stack<Item> implements Iterable<Item>`

|方法|功能|
|-|-|
|Stack()|构造一个空的栈|
|void push(Item item)|添加一个元素|
|Item pop()|删除一个元素|
|boolean isEmpty()|栈是否为空|
|int size()|返回栈中元素的个数|

##### 1.3.1.1 泛型

集合类的抽象数据类型的一个关键特性是我们应该可以用它们存储任意类型的数据。

泛型，就是为此设计的。

##### 1.3.1.4 背包

背包是一种不支持从中删除元素的集合数据类型。

它的目的就是帮助用例收集元素并迭代遍历所有收集到的元素。

迭代的顺序不确定且与用例无关。

##### 1.3.1.5 先进先出队列

队列是一种基于先进先出原则（FIFO）的集合数据类型。

队列是许多日常现象的自然模型，是无数应用程序的核心。

在应用程序中使用队列的主要原因：在用集合保存元素的同时保存它们的相对顺序：使得它们入列顺序与出列顺序相同。

##### 1.3.1.6 下压栈

下压栈是一种基于后进先出原则（LIFO）的集合数据类型。

当你的邮件在桌子上放成一叠时，使用的就是栈。

例如：许多人仍然用栈的方式存储电子邮件。

#### 1.3.2 集合类数据类型的实现

##### 1.3.2.1 定容栈

建立一个定容栈，即栈的大小是固定的。

实现以下方法：

1. `void push(Item item)` 添加一个元素
2. `Item pop()` 删除一个元素
3. `boolean isEmpty()` 栈是否为空
4. `int size()` 返回栈中元素的个数

```cpp
/*
* 定容栈：
* 实现以下方法：
* void push(Item item) - 添加元素
* Item pop() - 出栈一个元素
* boolean isEmpty() - 检验栈是否为空
* int size() - 查看栈有多少元素
*/
#include<iostream>
using namespace std;

template<typename T>
class EasyStack {
private:
	T* arr; // 存储栈元素的数组
	int top; // 栈顶指针
	int length; // 栈的容量
public:
	EasyStack(int l) {
		length = l;
		arr = new T[length];
		top = -1; // 初始化栈为空
	}
	~EasyStack() {
		delete arr;
	}
public:
	void push(T item) {
		if (top == length - 1) {
			cout << "Stack Overflow!" << endl;
			return;
		}
		
		top += 1;
		arr[top] = item;
	}

	T pop() {
		if (top == -1) {
			cout << "Stack is Empty!" << endl;
			return -1;
		}
		int temp = top;
		top -= 1;
		return arr[temp];
	}

	bool isEmpty() {
		return top == -1;
	}

	int size() {
		return top + 1;
	}
};

#if 0
int main() {
	EasyStack<int> es(5);
	es.push(5);
	es.push(4);
	es.push(3);
	es.push(2);
	es.push(1);

	cout << es.isEmpty() << endl;

	for (int i = 0; i < 5; i++) {
		cout << es.pop() << endl;
	}
	cout << es.isEmpty() << endl;
	
}
#endif
```

```java
package cn.foreveryang.stratofdream.bag;

public class Stack {
    private String[] a;
    private int n;
    public Stack(int cap) {
        a = new String[cap];
        n = -1;
    }
    public boolean isEmpty() {
        return n == -1;
    }

    public int size() {
        return n + 1;
    }

    public void push(String x) {
        n += 1;
        a[n] = x;
    }

    public String pop() {
//        int temp = n;
//        n -= 1;
//        return a[temp];
         return a[n--];
    }
}
```
