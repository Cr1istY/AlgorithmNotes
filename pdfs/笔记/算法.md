# 算法

本书使用的语言好像是java

## 第一章 基础

本章介绍的就是学习算法和数据结构所需要的基本工具。

> 算法：一种有序、确定、有效的并适合用计算机程序来实现的解决问题的方法。
> 算法是计算机科学的基础，是这个领域研究的核心。
> 数据结构是算法的副产品或是结果。
> 学习算法的主要原因是它们能节约非常多的资源。

### 1.1 基础编程模型

#### 1.1.1 java 程序的基本结构

```java
public class HelloWorld { 
    public static void main(String[] args) { 
        System.out.println("Hello World!");
        func();
    }
    public static void func() {
        System.out.println("Hello World!");
     }
}
```

#### 1.1.2 原始数据类型与表达式

- int - 整形
- double - 浮点型
- boolean - 布尔型
- char - 字符型

#### 1.1.3 语句

逻辑的基本语句有：声明、赋值、条件、循环、选择、调用和返回。

#### 1.1.4 简便记法

#### 1.1.5 数组

数组是存储多个相同类型的数据。

#### 1.1.6 静态方法

#### 1.1.7 API

API：应用程序接口

#### 1.1.8 字符串

在java中，字符串是被封装好的类String。

由自己的方法和属性。

#### 1.1.9 输入输出

#### 1.1.10 二分查找

我们要学习的第一个java程序的示例程序就是**著名**、**高效**并且**应用广泛**的**二分查找算法**。

```cpp
class BinarySearch {
/*
* 0. 前提，数组必须是有序的（假设它是正序）
* 1. 先得出数组的整体大小
* 2. 从中间开始比较，若要找的数字比中间值大，则将头指针移到中间值
* 3. 返回第一步
*/
public:
	int search(int arr[], int i, int size) {
		int max = size - 1;
		int min = 0;
		int mid = (max + min) / 2;
		while (max >= min) {
			if (arr[mid] == i) {
				return mid;
			}
			else if (arr[mid] < i) {
				min = mid + 1;
				mid = (max + min) / 2;
			}
			else if (arr[mid] > i) {
				max = mid - 1;
				mid = (max + min) / 2;
			}
		}
		return -1; // 没找到
	}
};

```

#### 1.1.11 展望

前进的这一步被称为数据抽象，有时也被称为面向对象编程，它是我们下一章的主题。

#### 1.1 练习

### 1.2 数据抽象

数据类型指的是一组值和一组对这些指的操作的集合。

抽象数据类型（ADT）是一种能够对使用者隐藏数据表示的数据类型。

抽象数据类型（实际上是class类）的主要不同之处在于它将数据和函数的实现关联，并将数据的表示方式隐藏起来。

详见java类

### 1.3 背包、队列和栈

许多基础数据类型都和对象的集合有关。

具体来说，数据类型的值就是一组对象的集合，所有操作都是关于添加、删除或是访问集合中的对象。

#### 1.3.1 API

背包：`public class  Bag<Item> implements Iterable<Item>`

|方法|功能|
|-|-|
|Bag()|构造一个空的背包|
|void add(Item item)|添加一个元素|
|boolean isEmpty()|判断背包是否为空|
|int size()|返回背包中元素的个数|

先进先出队列：`public class Queue<Item> implements Iterable<Item>`

|方法|功能|
|-|-|
|Queue()|构造一个空的队列|
|void enqueue(Item item)|添加一个元素|
|Item dequeue()|删除一个元素|
|boolean isEmpty()|队列是否为空|
|int size()|返回队列中元素的个数|

栈：`public class Stack<Item> implements Iterable<Item>`

|方法|功能|
|-|-|
|Stack()|构造一个空的栈|
|void push(Item item)|添加一个元素|
|Item pop()|删除一个元素|
|boolean isEmpty()|栈是否为空|
|int size()|返回栈中元素的个数|

##### 1.3.1.1 泛型

集合类的抽象数据类型的一个关键特性是我们应该可以用它们存储任意类型的数据。

泛型，就是为此设计的。

##### 1.3.1.4 背包

背包是一种不支持从中删除元素的集合数据类型。

它的目的就是帮助用例收集元素并迭代遍历所有收集到的元素。

迭代的顺序不确定且与用例无关。

##### 1.3.1.5 先进先出队列

队列是一种基于先进先出原则（FIFO）的集合数据类型。

队列是许多日常现象的自然模型，是无数应用程序的核心。

在应用程序中使用队列的主要原因：在用集合保存元素的同时保存它们的相对顺序：使得它们入列顺序与出列顺序相同。

##### 1.3.1.6 下压栈

下压栈是一种基于后进先出原则（LIFO）的集合数据类型。

当你的邮件在桌子上放成一叠时，使用的就是栈。

例如：许多人仍然用栈的方式存储电子邮件。

#### 1.3.2 集合类数据类型的实现

##### 1.3.2.1 定容栈

建立一个定容栈，即栈的大小是固定的。

实现以下方法：

1. `void push(Item item)` 添加一个元素
2. `Item pop()` 删除一个元素
3. `boolean isEmpty()` 栈是否为空
4. `int size()` 返回栈中元素的个数

cpp:

```cpp
/*
* 定容栈：
* 实现以下方法：
* void push(Item item) - 添加元素
* Item pop() - 出栈一个元素
* boolean isEmpty() - 检验栈是否为空
* int size() - 查看栈有多少元素
*/
#include<iostream>
using namespace std;

template<typename T>
class EasyStack {
private:
	T* arr; // 存储栈元素的数组
	int top; // 栈顶指针
	int length; // 栈的容量
public:
	EasyStack(int l) {
		length = l;
		arr = new T[length];
		top = -1; // 初始化栈为空
	}
	~EasyStack() {
		delete arr;
	}
public:
	void push(T item) {
		if (top == length - 1) {
			cout << "Stack Overflow!" << endl;
			return;
		}
		
		top += 1;
		arr[top] = item;
	}

	T pop() {
		if (top == -1) {
			cout << "Stack is Empty!" << endl;
			return -1;
		}
		int temp = top;
		top -= 1;
		return arr[temp];
	}

	bool isEmpty() {
		return top == -1;
	}

	int size() {
		return top + 1;
	}
};

#if 0
int main() {
	EasyStack<int> es(5);
	es.push(5);
	es.push(4);
	es.push(3);
	es.push(2);
	es.push(1);

	cout << es.isEmpty() << endl;

	for (int i = 0; i < 5; i++) {
		cout << es.pop() << endl;
	}
	cout << es.isEmpty() << endl;
	
}
#endif
```

java:

```java
package cn.foreveryang.stratofdream.bag;

public class Stack<T> {
    private T[] a;
    private int n;
    public Stack(int cap) {
        a = (T[]) new Object[cap];
        n = -1;
    }
    public boolean isEmpty() {
        return n == -1;
    }

    public int size() {
        return n + 1;
    }

    public void push(T x) {
        n += 1;
        a[n] = x;
    }

    public T pop() {
         return a[n--];
    }
}
```

```java
package cn.foreveryang.stratofdream.bag;

public class Test {
    public static void main(String[] args) {
        Stack<String> stack = new Stack<>(5);
        stack.push("a");
        stack.push("b");
        stack.push("c");
        stack.push("d");
        stack.push("e");
        System.out.println(stack.isEmpty());
        for (int i = 0; i < 5; i++) {
            System.out.println(stack.pop());
        }
        System.out.println(stack.isEmpty());
    }
}
```

##### 1.3.2.3 调整数组大小

在我们所写的栈中，我们使用了定长数组来实现数据的存储。

然而，这会导致两种潜在的问题：

1. 栈的容量有限，如果数据量过大，那么就会发生栈溢出。
2. 如果栈的初始容量定义得过大，就会造成内存空间的浪费。

因此，我们需要一种机制，能够动态地调整栈的容量，以解决上述问题。

1. 方法：isFull() - 检查栈是否已满 - 可以用扩容的方式，将栈从容量问题中解放出来
2. 方法：resize() - 扩容

```java
package cn.foreveryang.stratofdream.bag;

@SuppressWarnings("unchecked")
public class Stack<T> {
    private T[] a;
    private int n;

    public Stack(int cap) {
        a = (T[]) new Object[cap];
        n = -1;
    }
    public boolean isEmpty() {
        return n == -1;
    }

    public int size() {
        return n + 1;
    }

    // 当栈的长度不够时，考虑对栈进行扩容
    public void push(T x) {
        if (n + 1 == a.length) {
            resize(2 * a.length);
        }
        n += 1;
        a[n] = x;
    }

    // 当栈的长度过长时，考虑对栈进行缩容
    public T pop() {
        T temp = a[n];
        a[n] = null;
        n -= 1;
        if (n <= a.length / 4 && n >= 0) {
            resize(a.length / 2);
        }

        return temp;
    }

    private void resize(int cap) {
        T[] temp = (T[]) new Object[cap];
        if (n + 1 > 0) System.arraycopy(a, 0, temp, 0, n + 1);
        a = temp;
    }
}

```

如此，我们的栈永远都不会溢出，同时，使用率也不会少于四分之一。

关于数据的**动态扩容**的思想，是具有普遍性的，应该记住这样的范式。

##### 1.3.2.4 对象游离

java的垃圾回收机制是回收所有无法被访问的数据对象的内存。

在动态扩容栈的实现中，我们实际上已经无法访问`a[n]`对象了

但是，java的垃圾回收机制并不知道这一点，除非改引用被覆盖。

用例不再需要访问这个元素，但是数组中的引用却仍然使得它存在，这样保存一个不需要的对象的引用，就叫**对象游离**。

在这里，我们只需要将引用置为null，就能解决对象的游离。

###### 算法1.1 下压（LIFO）栈（能够动态调整数组大小的实现）

```java
package cn.foreveryang.stratofdream.bag;

import java.util.Iterator;

@SuppressWarnings("unchecked")
public class StackFinal<Item> implements Iterable<Item> {
    private Item[] a = (Item[]) new Object[1]; // 栈元素
    private int N = 0; // 
    public boolean isEmpty() {
        return N == 0;
    }
    public int size() {
        return N;
    }
    private void resize(int max) {
        Item[] temp = (Item[]) new Object[max];
        if (N > 0) {
            System.arraycopy(a, 0, temp, 0, N);
        }
        a = temp;
    }
    public void push(Item item) {
        if (N == a.length) {
            resize(2 * a.length);
        }
        a[N++] = item;
    }
    public Item pop() {
        Item item = a[--N];
        a[N] = null;
        if (N > 0 && N == a.length/4) {
            resize(a.length / 2);
        }
        return item;
    }

    @Override
    public Iterator<Item> iterator() {
        return new ReverseIterator();
    }
    
    private class ReverseIterator implements Iterator<Item> {
        private int i = N;
        public boolean hasNext() {
            return i > 0;
        }
        public Item next() {
            return a[--i];
        }
        public void remove() {}
    } 
}
```

- 这份泛型的可迭代的Stack API的实现是所有集合类抽象数据类型实现的模板。
- 他将所有元素都保存在数组中，并动态调整数组的大小，以保持数组大小和栈大小之比小于一个常数


